---
description: Binary modifying viruses
---

# Prependers and Postpenders

What's a _prepender_ you ask? Well, at the time of writing this section, I found an article by [@guitmz](https://github.com/guitmz) titled: [**"Linux.Fe2O3: a Rust virus"**](https://www.guitmz.com/linux-fe2o3-rust-virus/)  while looking for malware written in Rust (PoC mostly). This is where I encountered the term "prepender". As the name suggests the program aims to pre-append something to something. Long story short, it's essentially a kind of binary-infector/code-injector. A prepender injects some binary instructions at the _beginning of the program_, while a postpender would inject the same at the _end of the program._ Sounds lame, but it can really do some damage if paired with other types of malware.&#x20;



Anyways, this is a nice bit of insight on how one may inject binary instructions into an executable and cause it to do all kinda cool stuff, heck, you can probably compile a fork bomb and inject those instructions straight into something common like `cat` or `explorer.exe` and enjoy the show! Every time the user would try and use these basic commands, their systems would hang/crash.&#x20;

Before proceeding to the part where we make some pre/post-penders, here's a brief of what ELF/EXE files really are, i.e. their structures according to standard specifications:

### ELF - Executable and Linked Files

In the simplest of words, an ELF file consists of 2 parts, the **file headers,** and the **file data**. Simple. The file header ALWAYS begins with the following bytes:&#x20;

```
Magic Number Sequence:
        ELFMAG0    ELFMAG1    ELFMAG2    ELFMAG3
ASCII   0x7F       'E'        'L'        'F'
LE      7F         45         4C         46          (Little Endian)
BE      46         4C         45         7F          (Big Endian)
```

This "magic number" helps programs and OSs identify what kind a particular file is.&#x20;

After the magic number comes the `EI_CLASS` byte which specifies either 32 or 64-bit usage, followed by the `EI_DATA` byte which specifies the endianness. There are a whole bunch more bytes/sections before we get to the 18th byte, i.e. the `E_ENTRY` bytes. This header section may either be 4 or 8 bytes long for 32 and 64-bit architectures respectively and specifies the memory address of the [entry point](https://en.wikipedia.org/wiki/Entry\_point) from where the process starts executing.

> > If you're curious, by all means, please use something like `readelf` or `objdump` to inspect an ELF file and see all the fine details.&#x20;

As [@guitmz](https://github.com/guitmz) mentions in his blog, _A prepender works by appending its code to the star of the host file, and during execution, it runs itself and the host file..._ We can achieve this by dissecting the target host file, adding our instructions at the beginning all the while preserving its original workings, putting it back together, and making required changes in the headers.&#x20;

I'll be using [@guitmz](https://github.com/guitmz)'s blog as a guide/reference in implementing this.&#x20;

Let's use the following C program as our target.

```c
#include <stdio.h>

int main() {
    printf("Program executed...");
    return 0;
}
```

To generate the mentioned "_host file_":

```shell-session
$ gcc -o test test.c
$ file test 
test: ELF 64-bit LSB pie executable, x86-64, ...
```

We begin with some... _quality-of-life_ functions that'll help us work with ELF files:

```go
package prepender

import (
	"debug/elf"
	"io/ioutil"
	"log"
	"os"
)

var ELFMAG = []byte{0x7F, 'E', 'L', 'F'}

func CheckElf(file string) bool {
	content, err := ioutil.ReadFile(file)
	logError(err)

	return len(content) >= 4 && string(content[:4]) == string(ELFMAG)
}

func GetHeaders(file string) elf.FileHeader {
	f, err := os.Open(file)
	defer f.Close()
	logError(err)

	_elf, err := elf.NewFile(f)
	logError(err)

	return _elf.FileHeader
}

func GetContents(file string) map[string][]byte {
	f, err := os.Open(file)
	defer f.Close()
	logError(err)

	_elf, err := elf.NewFile(f)
	logError(err)

	sections := _elf.Sections
	var result = make(map[string][]byte)
	for _, section := range sections {
		if section.Flags&elf.SHF_EXECINSTR != 0 {
			instructions, err := section.Data()
			logError(err)
			result[section.Name] = instructions
		}
	}

	return result
}

func logError(e error) {
	if e != nil {
		log.Fatal(e)
	}
}
```

\---

It's a WIP, please be patient







### References

* [https://security.stackexchange.com/questions/157946/injection-of-code-into-executable-size-question](https://security.stackexchange.com/questions/157946/injection-of-code-into-executable-size-question)
*
